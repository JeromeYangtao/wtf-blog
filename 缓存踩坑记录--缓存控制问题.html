<title>缓存踩坑记录--缓存控制问题</title>
<meta name="description" content="">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<img class="logo" src="logo.png">

<x-markdown>
### 背景
1.刚学jQuery的时候做过一个小游戏，用到了window.location.reload()这个API进行页面刷新。但因为缓存问题出现了bug，而当时的我甚至都不知道缓存，折腾许久才解决，把上线时间推迟了几天

2.接手已经上线运营的**易道网球**时，一个用户出现了bug，紧急调整之后。但由于用户浏览器缓存的问题，仍然报错。最后通过产品经理让运营指导用户清除缓存解决...沟通成本时间成本耗费巨大，大家都不爽

两次被坑之后觉得以后痛定思痛，杜绝以后再出现类似情况，学习缓存控制相关知识后，记录下比较实用的解决方案

### URL + 查询参数
在我的另一篇博客[查询字符串踩坑记录](http://www.jianshu.com/p/0065b43ae5fb)中提到过，查询字符串不同意味着URL不一样，就不是同一份资源。不是同一份资源浏览器就会向服务器发起请求，让服务器返回对应的资源，**不会再使用缓存的资源**。这样就达到了控制缓存的目的。

具体操作就是**在引用的CSS和JS文件名后面加上查询参数，每次更改资源内容就更改查询参数**

下面是具体例子
```
<link rel="stylesheet" href="./css/style.css?version=1">
<script src="./js/index.js?version=1"></script>
```
每次更改JS和CSS文件，改变version后面的数值就能保证用户请求的是最新的资源了。
我们也可以选择不用具体数值而是用一个随机数，这样就可以保证用户每次请求的都是最新资源了。

这种控制缓存的方法在几年前比较流行，简单实用。

### cache-control
现在http消息头中设置
```
cacheControl:no-cache
```
可以让每次请求都不使用缓存的资源
```
cacheControl:public,max-age=3600
```
也可以设置一个使用最大时间内的缓存。在这个例子中，3600毫秒前缓存可以使用，3600毫秒后就不再使用该缓存，向服务器请求最新的资源

在http消息头中，类似的控制缓存的字段还有expire和last-modified。顾名思义就是通过判断过期时间和最后更新时间来就决定是否使用缓存。但都不是特别推荐使用。

**expire**使用的是绝对时间，如果用户更改了自己计算机上的时间，可能会出现一些意想不到的情况。
**last-modified**则主要是是因为http协议本身对他的描述就比较模糊，各浏览器对他的理解有所不同，也可能会遇到麻烦。

值得一提的是cache-control是从http1.1开始支持的

### ETag
ETag也是http消息头的一个字段。
具体做法是：服务器在第一次返回页面资源的时候附带上一个ETag值，之后浏览器每次请求都带上ETag，如果ETag和服务器一样，就使用缓存资源，否则返回最新资源。在服务端更新资源之后修改ETag值即可


### 小结
URL+查询字符串：纯前端操作，现在不流行
cache-control，ETag：现在的流行做法，http相关，与后端合作。cache-control节省了下载和请求，ETag节省了下载，仍需请求
</x-markdown>

<link rel="stylesheet" href="css/default.css">
<script src="js/marked.min.js"></script>
<script src="js/main.js"></script>
